### SSH KEY 생성

1. **리눅스 환경에서 key-gen**

    만약 기존에 SSH Key 를 생성해 놓은 분은 기존 SSH Key를 재사용해도 되므로 (1-1)을 건너뛰고 (1-2)로 넘어가도 됩니다. 혹은 SSH Key 를 생성해서 기존 SSH Key 를 덮어쓰기 (overwrite) 해도 됩니다.

    ```bash
    (base) dongwoo.jeong@heqdx ~ $ **ssh-keygen -t rsa -C "dongwoo.jeong@lge.com"**
    Generating public/private rsa key pair.
    Enter passphrase (empty for no passphrase): ********* (your_password_here)**
    Enter same passphrase again: ********* (your_password_here)
    Your identification** has been saved in /Users/dongwoo.jeong**/.ssh/id_rsa.
    Your public key** has been saved in /Users/dongwoo.jeong/**.ssh/id_rsa.pub.**
    ```

2. **공개 키 (Public Key) 가져오기 >> 복사 (copy)**

    인증키는 '/.ssh/id_rsa'에 저장이 되어있고, 공개 키 (public key)는 '/.ssh/id_rsa.pub'로 저장이 되어 있습니다. cat으로 공개키를 출력한 후에, 복사(copy)를 해두세요.

    ```bash
    (base) dongwoo.jeong@heqdx ~ $ **cat ~/.ssh/id_rsa.pub**
    ```

    공개 키가 출력되면 복사 (copy) 를 해두세요.  (2)번에서 GitHub에 붙여넣기 합니다.

    [https://t1.daumcdn.net/cfile/tistory/99A3C936600BEDA718](https://t1.daumcdn.net/cfile/tistory/99A3C936600BEDA718)

[출처] [https://rfriend.tistory.com/603](https://rfriend.tistory.com/603)

### GitLab 접속 및 계정 생성

1. GitLab 접속

    http://heqdx.lge.com/gitlab 주소로 접속하여 Register now 버튼을 누릅니다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d78d56d6-0469-49c9-ac17-3eb0ea4548f6/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d78d56d6-0469-49c9-ac17-3eb0ea4548f6/Untitled.png)

2. **GitLab 계정 등록 신청**

    해당되는 정보를 기입 후 Register 버튼을 누르면 가입 신청이 완료됩니다.
    이후 Root 계정 담당자의 가입 승인 후 사용 가능합니다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2420328-0d6a-4cba-8619-1bcf86d5668d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2420328-0d6a-4cba-8619-1bcf86d5668d/Untitled.png)

### SSH Key 등록

1. **환경 설정으로 이동**

    계정에 로그인 후 우측 상단의 계정 정보를 클릭 한 뒤 Preferences 버튼을 클릭합니다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67b4aa1d-43b0-4fce-9957-058122bfbe17/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67b4aa1d-43b0-4fce-9957-058122bfbe17/Untitled.png)

2. **SSH Keys 이동 및 Key 등록**

    2-1. 사이드바의 SSH Keys를 눌러 Key를 등록하는 페이지로 이동합니다.

    2-2. "SSH Key 생성" 시 복사한 public key를 붙여 넣습니다.

    2-3. Add key 버튼을 클릭합니다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd533465-6330-47ad-ab00-a2e4d00ee1b7/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd533465-6330-47ad-ab00-a2e4d00ee1b7/Untitled.png)

### **형상관리**

- 요약 : `clone -> 파일 수정 -> add -> commit -> push`
1. Clone : `clone`은 말 그대로 리모트 서버의 레파지토리에서 클라이언트로 파일을 복붙하는 행위

    ```bash
    $ cd ~/Project/ # 원하는 작업 디렉토리로 이동
    $ git clone https://github.com/evan-moon/test-repo.git
    ```

2. 파일 수정 : 작업을 위한 코드 수정
3. Add : 원하는 변경사항만 골라 담는 add 명령어

    ```bash
    $ git add . # 현재 디렉토리의 모든 변경사항을 스테이지에 올린다
    $ git add ./src/components # components 디렉토리의 모든 변경사항을 스테이지에 올린다
    $ git add ./src/components/Test.vue # 특정 파일의 변경사항만 스테이지에 올린다
    $ git add -p # 변경된 사항을 하나하나 살펴보면서 스테이지에 올린다
    ```

4. Commit : 변경 사항들을 포장하는 commit 명령어

    ```bash
    $ git commit -m "Select input 컴포넌트 추가" # 변경한 내용의 설명을 입력한다
    ```

5. Push : 변경 사항들을 리모트 서버로 배송하는 push 명령어

    ```bash
    $ git push origin master # origin 리모트 서버의 master 브랜치로 푸쉬해줘!
    ```

6. Pull : 리모트 서버의 최신 소스를 가져와서 로컬 소스에 `병합(Merge)`해주는 명령어

    ```bash
    $ git pull # master 브랜치의 변경사항을 클라이언트(내 작업환경)으로 추가해줘!
    ```

## 기초적인 개념 알아보기

Git은 분산 버전 관리 시스템이기 때문에 리모트 서버에 있는 소스를 수정하려면 로컬 환경으로 소스를 `클론(Clone)`하는 과정이 필요하다. 말 그대로 모든 소스를 복사하여 사용자의 컴퓨터로 받아오는 것이다.

이후 Git은 로컬 환경의 파일을 추적하고 있다가 사용자가 소스를 수정하면 그 변경 사항을 감지한다. 그 후 사용자는 자신이 리모트 서버에 변경 사항을 반영하고 싶은 파일이나 소스 코드의 라인을 고른 뒤 리모트 서버에 업로드한다.

맨 위의 `origin/master`는 리모트 서버의 버전, 맨 밑의 `master`는 필자 컴퓨터의 버전을 의미한다.

![https://evan-moon.github.io/static/e855c0870c0d6a21a168870d4ebbc553/c0388/source-tree.png](https://evan-moon.github.io/static/e855c0870c0d6a21a168870d4ebbc553/c0388/source-tree.png)

자 일단 Git에 대한 기본적인 개념은 이게 끝이다. 리모트 서버에 있는 파일을 내 컴퓨터로 복붙한 다음 수정해서 다시 리모트 서버로 업데이트한다는 것. 이때 사용자가 자신이 변경한 로컬의 소스를 서버의 소스에 업로드하는, 즉 서버로 밀어올리는 행위를 `Push`라고 부르고 사용자가 서버의 소스를 자신의 클라이언트로 가져오는 행위를 `Pull` 또는 `Fetch`라고 하는 것이다. 쉽지 않은가?

하지만 처음 Git을 접하면 평소에 접해보지 못했던 `remote`, `origin`, `repository`와 같은 용어들이 튀어 나오기 때문에 당황할 수 있다. 그럼 이 용어들이 무엇을 뜻하는지부터 간단하게 알아보자.

### Remote / Origin

우선 `Remote`는 말 그대로 리모트 서버 자체를 의미한다. 이 리모트 서버라는 개념이 잘 이해가 안되시는 분은 우리가 자주 사용하는 `구글 드라이브`나 `N드라이브`와 같은 클라우드 스토리지를 사용하는 것을 떠올리시면 된다. 전 세계 어딘가에 있는 서버에 우리의 소스를 저장하는 것이다.

이때 이 서버를 제공해주는 대표적인 업체가 `Github`, `Bitbucket`, `GitLab`과 같은 회사들이다. 이 회사들이 `Git`을 만든 게 아니라 `Git`이라는 시스템에 필요한 리모트 서버와 Git을 좀 더 편리하게 사용할 수 있는 기능들을 제공하는 것이다.

Git을 사용할 때는 내가 어떤 리모트 서버에 변경 사항을 업로드 할 것인지 정해야하는데, 반드시 하나의 리모트 서버만 사용할 수 있는 것이 아니기 때문에 내가 사용하는 리모트 서버의 이름을 정해줘야한다. 이때 주로 사용하는 관례적인 이름이 바로 `Origin`이다.

보통은 한 개의 리모트 서버만 운용하는 경우가 대다수이기 때문에 많은 사람들이 `Remote`와 `Origin`을 혼용해서 부르곤 한다.

### Repository

`레파지토리(Repository, Repo)`는 저장소라는 뜻으로, 리모트 서버 내에서 구분되는 프로젝트 단위라고 생각하면 된다. 우리가 구글 드라이브를 사용할 때도 하나의 디렉토리에 모든 파일을 다 때려넣지않고 몇 개의 디렉토리를 만들고 용도에 따라 파일을 나눠서 구분하는 것과 동일하다.

일반적으로 한 개의 레파지토리는 하나의 프로젝트를 의미하지만 경우에 따라서 레파지토리 하나에 여러 개의 프로젝트를 구성하기도 한다.

```jsx
https://github.com/user/repository.git
https://user@bitbucket.org/group-name/repository.git
```

레파지토리를 클론받을 때는 해당 레파지토리를 가리키는 URL이 필요한데, 레파지토리의 이름은 URL의 맨 마지막에 `.git` 확장자를 가지는 방식으로 표현된다.

### Branch

`브랜치`는 일종의 독립된 작업을 진행하기 위한 작업 공간의 개념이다. 맨 처음 Git을 초기화했을 때 기본적으로 `master`라는 이름의 브랜치가 하나 생성된다. 그 후 개발하는 기능 또는 버그 픽스에 따라서 브랜치를 새로 생성하고 거기서 작업한 후에 나중에 다시 `master`로 합치는 것이다.

master 브랜치에서 다른 브랜치를 분리한 모습

![https://evan-moon.github.io/static/3337736752b17e897031f2d2142cd163/6af66/branches.png](https://evan-moon.github.io/static/3337736752b17e897031f2d2142cd163/6af66/branches.png)

이 브랜치 개념은 Git에 익숙하지 않은 분들에게 잠깐 설명하고 넘어가기에는 직관적으로 이해가 잘 안될 수 있는 개념이기 때문에 추후 다른 포스팅에서 다시 설명하겠다. 일단 지금은 이 3가지 정도만 기억해두자.

> Git을 초기화하면 기본적으로 master 브랜치가 생긴다. 

이 친구가 메인 브랜치 역할을 한다.브랜치는 어떤 브랜치에서 분리시키는 것이고, 분리된 브랜치는 분리될 당시의 부모 브랜치 상태를 그대로 가지고 있다.

개발자는 각각의 브랜치에서 개발을 진행한 뒤 나중에 다시 master 브랜치로 변경 사항을 합친다.

## 필수 명령어들을 알아보자

만약 여러분이 혼자서만 프로젝트의 버전 관리를 한다면 단순히 리모트 서버의 레파지토리에서 소스를 받아와서 변경한 후 다시 리모트 서버로 업로드하는 과정만으로도 프로젝트를 진행하는데는 사실 아무 문제가 없다.

하지만 Git은 애초에 혼자서 개발하는 상황보다는 여럿이서 함께 소스를 수정하며 개발하는 협업 상황을 상정하고 만들었기 때문에 협업에서 발생할 수 있는 여러가지 곤란한 상황들을 타파하기 위한 많은 기능을 가지고 있다.

Git은 기본적으로 `CLI(Command Line Tools)`을 통해 사용하고 `commit`, `fetch`, `branch`와 같은 여러가지 명령어를 사용하여 이 기능들을 사용할 수 있게 해준다.

그럼 이번에는 Git을 사용하여 버전을 관리하기 위해 기본적으로 알아야 하는 몇 가지 명령어를 한번 살펴보자.

## 리모트 서버와 연동하기

### clone

`clone`은 말 그대로 리모트 서버의 레파지토리에서 클라이언트로 파일을 복붙하는 행위를 말한다. 이때 클론을 수행하기 위해서는 `어떤 레파지토리`에서 파일을 가져올 것인지에 대한 정보가 필요한데, 이 정보는 위에서 설명했듯이 URL로 표현한다. `HTTPS` 프로토콜이나 `SSH` 프로토콜을 사용하여 소스를 클론할 수 있는데, 보통 `HTTPS`를 많이 사용한다.

![https://evan-moon.github.io/static/3623cc98a57b0f252f1a6ea7e513bf3f/f816d/clone.png](https://evan-moon.github.io/static/3623cc98a57b0f252f1a6ea7e513bf3f/f816d/clone.png)

보통 Github과 같은 리모트 서버 제공업체들은 레파지토리를 쉽게 클론할 수 있도록 눈에 잘 띄는 버튼을 만들어 놓고 해당 레파지토리의 URL을 제공하는 경우가 많다. 사용자는 단지 저 URL을 복사한 다음 Git의 `clone` 명령어를 사용해서 레파지토리를 클론하기만 하면 된다.

```jsx
$ cd ~/dev/evan # 원하는 작업 디렉토리로 이동
$ git clone https://github.com/evan-moon/test-repo.git
```

원하는 작업 디렉토리로 이동한 뒤 `clone` 명령어를 사용하여 레파지토리를 클론하게되면 현재 위치에 레파지토리 이름과 동일한 디렉토리가 생성되고 그 내부에 리모트 서버의 소스가 전부 복사된다. 위 예제의 경우 `~/dev/evan` 디렉토리 내부에 `test-repo` 디렉토리가 생성되고 해당 레파지토리의 소스가 복사될 것이다.

이제 이 복사된 소스를 맘대로 수정하거나 파괴해도 리모트 서버에 업로드만 하지 않는다면, 같은 리모트 서버를 보고 있는 다른 사람이 영향을 받을 일은 절대 없기 때문에 안심하고 맘대로 만지작거려도 된다.

### pull

`pull` 명령어는 리모트 서버의 최신 소스를 가져와서 로컬 소스에 `병합(Merge)`해주는 명령어이다. 만약 우리가 처음 소스를 클론한 후에 다른 사람이 리모트 서버를 상태를 갱신했더라도 리모트 서버가 우리에게 그 변경된 사항을 알려주지는 않기 때문에 우리가 직접 서버에 문의를 날려야 하는 것이다.

또한 `pull`은 단순히 리모트 서버에서 로컬로 소스를 가져온다의 개념보다는 `가져와서 합친다`의 개념이기 때문에 브랜치끼리도 `pull`을 통해 소스를 합칠 수 있다.

```jsx
$ git pull # 현재 내 로컬 브랜치와 같은 이름을 가진 리모트 서버 브랜치가 타겟
$ git pull origin master # origin 리모트 서버의 master 브랜치가 타겟
```

오픈소스에 관심이 많은 분이라면 `Pull Request`라는 단어를 들어보았을 것이다. 이 `Pull Request`는 “내가 작업한 브랜치를 가져가서 합쳐줘~“라는 의미이다.

필자는 처음에 이게 왜 `Merge Request`가 아니라 `Pull Request`인지 이해가 잘 안갔었는데, 나중에 와서 생각해보니 최종적으로 두 브랜치의 소스를 합치는 행위를 하는 주체가 요청을 한 사람이 아니고 요청을 받은 사람이기 때문에 요청을 받은 사람이 브랜치를 가져가서 합친다는 관점에서 보면 적절한 네이밍인 것 같다는 생각을 했었다.

### fetch

`fetch`는 리모트 서버의 최신 이력을 내 클라이언트로 가져오되 병합은 하지 않는 명령어이다.

`$ git fetch`

`fetch` 명령어를 사용하면 다른 사람들이 리모트 서버에 새로 업데이트한 모든 내역을 받아올 수 있다. 이제 그 내역을 보고 내 로컬에 있는 버전이 리모트 서버에 있는 버전보다 이전 버전이라면 `pull` 명령어를 사용하여 내 컴퓨터의 소스 코드를 갱신하면 된다.

그럼 이 명령어가 `pull`의 하위 호환이 아닌가? 라는 생각이 들 수도 있는데, `pull`과 `fetch`는 조금 용도가 다르긴 하다. `pull` 같은 경우는 일단 묻지도 따지지도 않고 바로 리모트 서버의 최신 소스를 가져와서 내 로컬 소스에 합쳐버리기 때문에 조금 위험하긴 하다. 뭐 예를 들면 지금 리모트 서버의 최신 소스가 버그가 있는 상태일 수도 있지 않은가?

그래서 필자같은 경우 보통 로컬 소스와 리모트 소스의 변경 사항을 미리 비교해보고 싶을 때 `fetch`를 사용한다. 그리고 `fetch`를 잘 이용하면 이런 얌생이도 가능하다.

```jsx
**#!/bin/bash**git fetch --all -p; git branch -vv | grep ": gone]" | awk '{ print $1 }' | xargs -n 1 git branch -d
```

이 쉘스크립트는 필자가 예전에 만들어 놨던 친구이다. `fetch`를 통해 리모트 서버의 최신 내용을 받아온 뒤, `branch` 명령어를 사용하여 리모트 서버에서는 삭제되었지만 로컬에는 남아있는 브랜치를 찾아서 싹 다 지워주는 스크립트이다. 참고로 로컬에는 있지만 리모트에서 삭제된 브랜치는 브랜치 이름 뒤에 `: gone`이라는 문구가 붙어있기 때문에 구분이 가능하다.

```jsx
$ git branch -vv
* master fa0cec5 [origin/master] 마스터 브랜치에욤
  test   1f3578f [origin/test: gone] 리모트에선 죽은 브랜치
  test2  fa0cec5 로컬에서 만들어지고 리모트에 업데이트는 안된 브랜치
```

`fetch` 명령어와 `branch` 명령어의 특성을 잘 이용하면 이런 꿀 스크립트를 만들 수도 있다.

## 변경 사항을 리모트 서버에 업데이트하기

자, 지금까지는 리모트 서버의 내용을 로컬과 연동하는 명령어를 살펴봤다면 이제는 내 로컬에서 변경한 소스를 리모트 서버로 업로드하는 명령어들을 살펴볼 차례이다. 필자는 이 과정을 설명할 때 보통 `택배`로 예를 주로 드는 편이기 때문에 이 포스팅에서도 택배를 포장하고 배송하는 과정에 빗대어서 설명을 진행하겠다.

### add

원하는 변경사항만 골라 담는 add 명령어

![https://evan-moon.github.io/static/67e9fbfe9c838c78850347beaaa2bf25/c08c5/add.jpg](https://evan-moon.github.io/static/67e9fbfe9c838c78850347beaaa2bf25/c08c5/add.jpg)

자, 평화로운 `중*나라`에서 중고 거래를 했다고 생각해보자. 물론 집에 있는 모든 물건을 보내는 혜자같은 분도 계시겠지만 일반인이라면 그러지 않기 때문에 우리는 상대방한테 물건을 보내기 전에 어떤 물건을 보낼 것인지 부터 정해야한다. 이때 `add` 명령어가 어떤 물건들을 포장할 것인지 고르는 과정을 담당한다.

```jsx
$ git add . # 현재 디렉토리의 모든 변경사항을 스테이지에 올린다
$ git add ./src/components # components 디렉토리의 모든 변경사항을 스테이지에 올린다
$ git add ./src/components/Test.vue # 특정 파일의 변경사항만 스테이지에 올린다
$ git add -p # 변경된 사항을 하나하나 살펴보면서 스테이지에 올린다
```

이때 선택된 변경 사항들은 `스테이지(Stage)`라고 불리는 공간으로 이동하게 된다. 이때 `git add <경로>` 명령어는 해당 경로 안에 있는 변경 사항을 전부 스테이지에 올리게 되는데, 이게 영 불안하다 싶은 사람은 `-p` 옵션을 줌으로써 변경 사항을 하나하나 확인하면서 스테이지에 올릴 수도 있다.

이렇게 스테이지에 담긴 변경 사항들은 `git status` 명령어를 사용하여 확인해볼 수 있고, `status` 명령어에 추가적으로 `-v` 옵션을 사용하면 어떤 파일의 어떤 부분이 변경되었는지도 함께 볼 수 있다.

```jsx
$ git add ./soruce
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   source/_drafts/git-tutorial.md
```

### commit

변경 사항들을 포장하는 commit 명령어

![https://evan-moon.github.io/static/fd06caf7ac6bf4a5b01786357ca96bc8/c08c5/commit.jpg](https://evan-moon.github.io/static/fd06caf7ac6bf4a5b01786357ca96bc8/c08c5/commit.jpg)

`add`를 사용하여 원하는 변경사항을 스테이지에 올렸다면 이제 스테이지에 있는 변경 사항들을 포장할 차례이다. 이때 이 포장하는 행위를 `commit`이라고 한다. 커밋은 Git에서 상당히 중요한 부분을 차지하는 행위인데, 바로 Git이 하나의 커밋을 하나의 버전으로 정의하기 때문이다. 그렇기 때문에 특정 버전으로 어플리케이션을 변경이라는 기준도 당연히 바로 이 커밋이 된다.

```jsx
$ git log --graph

* commit 20f1ea9 (HEAD -> master, origin/master, origin/HEAD)
| Author: Evan Moon <bboydart91@gmail.com>
|
|     회원가입 기능 개발 끝!
|
* commit ca693fd
| Author: Evan Moon <bboydart91@gmail.com>
|
|     회원가입 비밀번호 입력 폼 추가
|
* commit f9b6e2d
| Author: Evan Moon <bboydart91@gmail.com>
|
|     회원가입 이메일 입력 폼 추가
|
```

위의 그래프 상에서 필자의 어플리케이션의 현재 상태는 어떤 커밋일까?

그래프 상에서 `HEAD`가 `20f1ea9 회원가입 기능 개발 끝!` 커밋에 위치해 있으므로 현재 필자의 어플리케이션은 `회원가입 기능`까지 개발이 완료된 상태라는 것을 알 수 있다.

그리고 그래프를 자세히 보면 각각의 커밋들은 `20f1ea9`과 같은 고유한 해쉬 값을 가지고 있는데, 이 해쉬 값을 사용하여 어떠한 커밋으로든 자유자재로 이동할 수 있다. 예를 들면 `회원가입 비밀번호 입력 폼 추가` 커밋의 해쉬 값을 사용하여 `git checkout ca693fd` 명령어로 회원가입 비밀번호 입력 폼이 추가된 시점으로 이동할 수 있다는 것이다. 즉, 시간여행이 가능하다!

이러한 커밋의 기능을 제대로 활용하기 위해서 커밋은 반드시 실행 가능한 단위로 해야한다. 더 쉽게 말하자면 특정 커밋으로 버전을 변경했을 때 어플리케이션이 제대로 실행되지 않고 에러가 발생하면 안된다는 것이다.

그리고 위의 예제에서 볼 수 있듯이 커밋에는 메세지를 담을 수 있다. 이 메세지는 이 커밋으로 인한 변경 사항이 무엇인지 직접적으로 표현해주는 유일한 수단이므로 좋은 커밋 메세지를 작성하기 위한 고민은 필수다. 다행히도 이미 많은 개발자 분들이 좋은 커밋 메세지를 어떻게 작성해야 하는지에 대해 포스팅을 해주셨기 때문에 구글에서 한번 검색해보면 수두룩하게 나온다.

참고로 커밋 메세지는 꼭 영어여야 할 필요는 없다. 조직에 따라서 커밋 메세지를 영어로만 작성하도록 강제하는 룰이 있을 수는 있지만, 사실 커밋 메세지는 결국 커뮤니케이션 수단이므로 언제 누가 보더라도 알아보기 쉽게만 작성하면 장땡이다. 그러니까 영어가 익숙하지 않은데도 불구하고 굳이 영어를 고집할 필요는 없다. 오히려 같이 협업하는 팀원들이 영어에 익숙하지 않다면 그 또한 불필요한 커뮤니케이션 비용이 될 수 있다.

또한 커밋은 아직 리모트 서버에 파일을 전송하는 것이 아니라 사용자의 클라이언트 내에서 수행되는 과정이므로 인터넷에 연결이 되어 있지 않아도 변경 사항을 커밋하는 것은 아무런 지장이 없다.(비행기에서 코딩할 때도 커밋까지는 가능하다!)

사실 필자는 Git 뉴비일 때 이 커밋이라는 단어가 조금 헷갈렸었는데, 많은 개발자 분들이 `commit`과 `push`를 같은 의미로 사용하기 때문이었다. 하지만 이 두 명령어는 엄연히 다른 역할을 하기 때문에 되도록이면 구분해서 사용하도록 하자.

### push

변경 사항들을 리모트 서버로 배송하는 push 명령어

![https://evan-moon.github.io/static/8fb4fd3977a800aa1b5e49daad8abee0/c08c5/push.jpg](https://evan-moon.github.io/static/8fb4fd3977a800aa1b5e49daad8abee0/c08c5/push.jpg)

커밋을 통해 포장된 변경 사항들은 `push` 명령어를 사용하여 리모트 서버로 업로드 된다. 이때는 커밋된 변경 사항들을 실제 리모트 서버에 `전송`하는 것이기 때문에 반드시 네트워크에 연결이 되어있어야 한다. 그리고 푸쉬할 때 반드시 A 로컬 브랜치는 A 리모트 브랜치에만 푸쉬해야 한다는 룰 따윈 없기 때문에 커밋들을 리모트 서버로 푸쉬할 때는 Git에게 “어떤 리모트 서버의 어떤 브랜치로 푸쉬할 것인지”도 함께 알려줘야 한다.

```jsx
$ git push origin master # origin 리모트 서버의 master 브랜치로 푸쉬해줘!
```

근데 이게 브랜치 이름이 `master`정도면 그래도 브랜치 이름을 매번 입력해줄만 하지만 `feature/SD-0000-request-api-refactoring` 정도 되면 브랜치 이름을 매번 입력한다는 것이 귀찮을 수도 있다.

그래서 Git은 브랜치를 자동으로 추적할 수 있는 기능 또한 제공해준다.

```jsx
$ git push --set-upstream origin master
```

- `-set-upstream` 옵션을 사용하고 처음 한번만 브랜치 이름을 입력해주면 그 이후로는 `git push` 명령어만 입력해도 자동으로 처음 입력했던 브랜치로 변경 사항을 푸쉬할 수 있다.

이렇게 해서 리모트 서버의 레파지토리에서 소스를 내 컴퓨터에 받아온 뒤 파일을 변경하고, 그 변경 사항을 리모트 서버에 다시 업데이트하는 `clone -> 파일 수정 -> add -> commit -> push`과정을 한번 살펴보았다.

## 용어와 개념 알아보기

Git은 버전을 효율적으로 관리하기 위해 몇 가지 개념을 제시하고 있다. 현재 나의 버전 상태를 의미하는 `HEAD`, 작업 공간인 `브랜치(Branch)`, 브랜치를 합치는 `머지(Merge)`와 `리베이스(Rebase)`등이 그렇다. 그리고 이런 기능들을 사용하다보면 가끔 Git의 `에러`와 마주하게 되는데, 필자같은 경우는 처음 개발자로 일을 시작했을 때 코딩하다가 발생하는 에러보다 Git에서 발생하는 에러가 더 무서웠던 기억이 있다. 솔직히 코딩하다가 나는 에러는 고치는 과정이 쉽든 어렵든간에 그냥 필자가 고치면 해결되지만, Git에서 나는 에러는 고친답시고 이것 저것 건드리다가 잘못 건드리면 왠지 소스가 가루가 되어 날아갈 것 같아서 무서웠다.

하지만 Git을 사용한 지 6년쯤 지난 지금 다시 그때를 생각해보면 Git에 대해서 잘 몰랐기 때문에 더 무서웠던 것 같다. 내가 어떤 기능을 사용했을 때 소스가 어떻게 되는 지 정확히 알고 있지 않은 상태였기 때문에 그런 걱정도 들었던 것이다. 혹시 이 글을 읽는 독자 분들 중에서도 필자와 같은 경험이나 생각을 하신 분들이 있을 것이기 때문에 필자가 알고 있는 Git의 개념들을 최대한 알기 쉽게 풀어보려고 한다.

### Merge Conflict

필자 생각에 Git을 사용하다가 가장 많이 마주치는 에러는 아무래도 `머지 컨플릭트(Merge Conflict)`인 것 같다. 에러라고 하기에는 조금 애매하긴 하지만 어쨌든 정상은 아닌 상황이기 때문에 처음 마주하면 굉장히 당황스럽고 뭐가 뭔지 헷갈린다. 컨플릭트는 말 그대로 `소스의 충돌`이 발생한 상황이기 때문에 주니어든 시니어든 가리지 않고 평등하게 발생하고, 또한 평등하게 당황하게 된다.

왜냐면 컨플릭트는 논리적인 에러가 아니라 내 작업물과 다른 사람의 작업물이 충돌한 상황이기 때문에 스스로 혼자 해결하기 힘든 경우가 많기 때문이다. 그럼 컨플릭트, 즉 충돌이 정확히 어떤 상황을 말하는 지 알기 위해 실제 협업 상황에서 발생할 수 있는 예시를 함께 살펴보자.

> 철수와 영희는 사장님으로부터 지각한 사람의 명단을 만들어서 관리해 달라는 부탁을 받았다. 
그래서 철수와 영희는 다음과 같은 텍스트 파일을 만들어서 지각자를 관리하기 시작했다.

```jsx
7월 25일 지각자 명단

나연
채영
사나
쯔위
```

> 자, 이제 철수와 영희는 사장님으로부터 지각자를 관리할 수 있는 권력을 부여받았고, 매일 이 파일에 지각자를 입력해야한다. 하지만 철수와 영희는 별로 사이가 안 좋기 때문에 이 둘은 서로 커뮤니케이션을 하지 않고 각자 맘대로 파일을 수정하는 방식으로 지각자 입력 작업을 진행하게 된다.

그러던 중 철수와 영희는 사무실에 심어놓은 자신들의 정보원으로부터 7월 25일의 세번째 지각자인 사나가 사실 지각이 아니였다는 정보를 입수했다. 근데 문제는 이 정보원들이 가져온 정보가 서로 달랐던 것이다.

철수의 정보원: 야 7월 25일에 지각한 사람 있잖아, 사나가 아니고 미나래!
영희의 정보원: 영희야, 7월 25일에 사나가 지각한게 아니고 지효가 지각한거라는데?

…

이 둘은 자신의 정보원을 100% 신뢰하기 때문에 바로 각자 지각자 명단 파일을 수정하기 시작했다.

[제목 없음](https://www.notion.so/340151df6b894357845b6e9ba6785899)

```jsx
From https://github.com/evan-moon/conflict-test
 * branch            test       -> FETCH_HEAD
Auto-merging 지각자.txt
CONFLICT (content): Merge conflict in 지각자.txt
Automatic merge failed; fix conflicts and then commit the result.
```

이렇게 다른 사람과 내가 같은 부분을 수정하게 되면, Git은 어떤 것이 맞는 소스인지 알 방법이 없다. 이런 상황에서 Git은 어떤 부분이 충돌났는지 표시하여 사용자에게 알려주기만 하고 나머지는 사용자가 알아서 수정하라고 맡겨버리는데, 이런 상황이 바로 `병합 충돌(Merge Conflict)`이다.

철수와 영희 처럼 같은 브랜치에서 작업한다는 것은 소스의 변경 사항을 계속 히스토리를 공유한다는 것이다. 즉, 주기적으로 리모트 저장소로부터 상대방이 작업한 것을 `Pull`로 가져와서 내 로컬 브랜치에 병합해야한다는 것인데, 이 과정에서 충돌이 발생할 가능성이 높다.

```jsx
7월 25일 지각자 명단

나연
채영
<<<<<<< HEAD
지효
=======
미나
>>>>>>> 35058b46325bb61112efd52f4019f907c561328d
쯔위
```

이때 `<<< HEAD`와 `===`사이에 들어있는 상단 부분이 현재 브랜치에서 내가 수정한 내용이다. 영희는 `사나`를 `지효`로 수정했기 때문에 해당 부분에 `지효`라는 이름이 들어가 있다.

그리고 `===`부터 `>>> 커밋 해쉬`사이의 내용은 어떤 커밋에서 수정된 내용과 충돌이 발생했는지 알려준다. 이 예시에서는 철수가 `사나`를 `미나`로 수정한 부분이 될 것이다.

Git은 그냥 버전 관리만 해주는 친구이기 때문에 이런 상황에서 “사나는 사실 지각자가 아니였기 때문에 다른 사람으로 변경해야했다”와 같은 비즈니스 히스토리는 모른다. 그렇기 때문에 Git은 둘 중에 어떤 것이 맞는 소스인지도 당연히 모를 수 밖에 없다. 그래서 사용자에게 선택을 맡기는 것이다. 이 상황에서 영희는 다음 세가지 선택지를 가질 수 있다.

> 철수의 변경 사항을 무시자신의 변경 사항을 무시두 변경 사항 모두 반영

보통 이런 상황에서는 철수를 불러서 `사나` 대신 `미나`를 추가한 이유가 무엇인지 물어본 다음 결정해야하지만 영희는 철수와 사이가 좋지 않으니 그냥 철수의 커밋을 날려버릴 수도 있겠다. (실제 상황에서 함부로 이러면 혼납니다)

### 여러 개의 Branch를 사용하는 이유

`브랜치(Branch)`는 [저번 포스팅](https://evan-moon.github.io/2019/07/25/git-tutorial)에서 한번 간단하게 설명했다. 이미 저번 포스팅에서 기초적인 브랜치의 개념에 대해서 한번 언급하고 넘어갔기 때문에 이번에는 “왜 여러 개의 브랜치를 사용해야 하는가?”에 대한 이야기를 해보려고 한다.

기본적으로 Git은 혼자 만의 작업이 아닌 여러 명이 함께 작업하는 협업 상황을 상정하고 만들어졌다. 아무리 Git이 리모트 레파지토리와 로컬 레파지토리로 소스를 분산해서 관리하는 `분산 버전 관리 시스템`이지만 여러 사람이 한번에 같은 어플리케이션의 코드를 수정하고 있는 상황에서는 방금 위에서 설명한 `머지 컨플릭트`가 자주 발생하게된다. 그래서 보통 사용자들은 `브랜치`로 주제에 맞는 작업 공간을 따로 나누어서 히스토리를 관리하는 것이다.

이렇게 브랜치를 나누어도 결국 언젠가 소스를 병합해야 하기 때문에 컨플릭트가 발생할 확률은 있지만 적어도 작업 중간중간에 계속 해서 컨플릭트를 수정해야하는 일은 많이 줄일 수 있다. 그래서 개발자들은 “어떻게 해야 효율적으로 여러 개의 브랜치를 관리할 수 있을까?”라는 고민을 하게 되는데, 이때 나온 것이 바로 `브랜치 전략`이다. 브랜치 전략 중 대표적인 것은 `Git flow`가 있는데, 이건 그냥 유명한 전략 중 하나일 뿐이기 때문에 어떤 브랜치 전략을 가져갈 것인지는 그 조직이 결정하면 된다.

그럼 브랜치 전략이 어떤 것인지 알아보기 위해 대표적인 브랜치 전략인 `Git flow`를 한번 간략하게 살펴보도록 하자.

### 전략적인 브랜치 관리, Git flow

`Git flow`는 기본적으로 `master`와 `develop` 브랜치를 가지고 시작하게 된다. 이때 `master`는 항상 운영되고 있는 소스의 상태를 가지고 있어야하며, 절대 `master` 브랜치에는 바로 커밋을 할 수 없다. 그리고 `develop` 브랜치는 팀이 현재 개발을 진행하고 있는 브랜치이다. 그리고 `develop` 브랜치에서 각자 개발을 맡고 있는 기능 별로 `feature` 브랜치를 생성해서 실제 개발을 진행하게 된다.

![https://evan-moon.github.io/static/36200b7d3489370e101d9715d3b4da42/6af66/git-flow1.png](https://evan-moon.github.io/static/36200b7d3489370e101d9715d3b4da42/6af66/git-flow1.png)

모바일에서는 이 그래프의 내용이 잘 안보일 수 있으니 브랜치 이름에 색을 입혀서 설명하도록 하겠다.

이 그래프를 보면 **master** 브랜치에 프로젝트의 시작을 의미하는 커밋이 찍힌 후 **develop** 브랜치가 생성되었고, **develop**에서부터 기능 개발을 담당하는 브랜치들이 분기하고 있는 모습을 볼 수 있다.

에반은 **feature/add-typescript** 브랜치를 생성한 후 어플리케이션에 타입스크립트를 붙히는 작업을 하고, 다니엘은 **feature/social-login** 브랜치를 생성한 후 소셜 로그인 연동 작업을 하고 있다. 그 후 개발이 끝나는 대로 **develop** 브랜치에 해당 브랜치들을 차례로 머지하고 있는 모습을 볼 수 있다.

다니엘이 에반보다 **develop** 브랜치에 머지한 시점이 늦기 때문에 만약 에반과 다니엘이 같은 부분을 변경했다면 이때 컨플릭트가 발생하게 된다. 하지만 적어도 에반과 다니엘이 각자 기능을 개발하고 있을때는 컨플릭트가 발생하지 않기 때문에 좀 더 기능 개발에 집중할 수 있게 되는 것이다.

이렇게 개발을 쭉쭉 진행하다가 배포를 해야할 시점이 오면 **master**로부터 `release`브랜치를 생성한다. 필자의 직장같은 경우는 `release/release-1.0.0`과 같이 배포 버전을 브랜치 이름에 표기하는 네이밍 컨벤션을 따르고 있다. 이 `release` 브랜치는 온전히 배포 만을 위한 브랜치이기 때문에 해당 버전의 배포가 끝나면 버려진다.

![https://evan-moon.github.io/static/fcb2177c59a4abcc0f9eabce70541126/6af66/git-flow2.png](https://evan-moon.github.io/static/fcb2177c59a4abcc0f9eabce70541126/6af66/git-flow2.png)

개발이 종료되고 `1.0.0` 버전을 배포하기 위해 **release/release-1.0.0**이라는 노란색 브랜치를 **master**로부터 하나 생성했다. 그 후 다음 버전에 배포될 기능들을 가지고 있는 **develop** 브랜치를 **release/release-1.0.0** 브랜치에 머지하고 스테이징 서버에 배포하는 등 최종 테스트를 한 다음, 조직원 모두가 해당 버전의 배포에 동의한다면 **master** 브랜치에 해당 브랜치를 머지하고 버전명으로 태그를 단다.

이때 이런 궁금증이 생기는 분이 있을 것이다.

> 그럼 핫픽스는 어떻게 하나요? develop 브랜치에서 브랜치를 분기하면 현재 버전의 기능 개발이 끝날 때까지 기다려야하는데…

이런 경우 `develop` 브랜치에서 `hotfix` 브랜치를 분기하여 `master`로 머지 후 긴급 배포를 하게되면 `develop` 브랜치에 들어있는 아직 배포되지 말아야할 기능들까지 배포되기 때문에, 핫픽스는 예외적으로 `master`에서 분기해서 다시 `master`로 머지할 수 있다.

![https://evan-moon.github.io/static/6ce98c7e9ed5003464a381a69b640a7e/6af66/git-flow3.png](https://evan-moon.github.io/static/6ce98c7e9ed5003464a381a69b640a7e/6af66/git-flow3.png)

그래프가 조금 복잡해졌지만 검정색 라인인 **hotfix/fix-main-page**에만 집중해보자. **master** 브랜치로부터 갈라져나와서 한 개의 커밋이 찍히고 다시 **master**로 머지되는 것을 볼 수 있다. 이때는 정식 릴리즈가 아닌 핫픽스 릴리즈이므로 [Sementic Version](https://semver.org/lang/ko/) 룰에 따라 `0.0.1` 버전의 태그를 달아주었다.

**hotfix/fix-main-page** 브랜치가 머지되고 배포가 되었다는 것은 현재 운영 환경에서 돌아가고 있는 소스가 변경되었다는 것이므로 **develop** 브랜치에도 해당 변경 사항을 반영해줘야한다. 그렇기 때문에 핫픽스 담당자는 배포를 하고 나면 `develop` 브랜치를 직접 최신화하는 것이 좋다. 그리고 동료들에게 “지금 핫픽스 배포가 끝났으니 각자 작업하시는 브랜치에서 develop 브랜치를 Pull하여 최신화 해주세요~“라고 알려주면 더더욱 좋을 것이다.

물론 이런 복잡한 브랜치 전략 없이도 그냥 잘 돌아가는 조직도 있다. 하지만 같은 소스를 만지는 개발자가 많아지면 많아질수록 어느 정도의 룰조차 없다면 원활한 협업이 진행되기는 힘들 수도 있기 때문에 대부분의 규모있는 조직에서는 각자의 상황에 맞는 브랜치 전략을 세워서 버전 관리를 진행하고 있다.

브랜치를 왜 하나로만 운영하지 않는지 이해가 되었다면, 이제 이 브랜치와 버전 히스토리들을 가지고 놀 수 있는 몇 가지 유용한 기능들을 더 살펴보도록 하자.

## 두 개의 브랜치를 합쳐보자

각자의 브랜치에서 작업을 계속 진행하다보면 언젠가 두 브랜치를 합쳐야 하는 날이 다가온다. 이때 두 개의 브랜치를 합치는 행위를 `브랜치 병합(Branch Merge)`이라고 한다. Git은 `Merge`, `Merge and Squash`, `Rebase` 각각 특색있는 3개의 브랜치 병합 기능을 제공한다. 결국 이 3개의 명령어 모두 두 개의 브랜치를 합친다는 행위는 같지만, 합치는 방법도 다르고 버전 히스토리도 다르게 남기 때문에 적재적소에 이 기능들을 잘 이용한다면 팀원들에게 이쁨받는 깃쟁이가 될 수 있을 것이다.

### Merge

![https://evan-moon.github.io/static/3d89813d37e675e64e3f97f8b98c8e28/c08c5/merge_icon.jpg](https://evan-moon.github.io/static/3d89813d37e675e64e3f97f8b98c8e28/c08c5/merge_icon.jpg)

`머지(Merge)`는 제일 기본적인 브랜치 병합 기능으로, 합치려고 하는 대상 브랜치의 변경 사항을 타겟 브랜치에 모두 반영하면서 `머지 커밋(Merge commit)`을 남긴다.

```jsx
$ git checkout master
$ git merge feature
```

일반적인 머지는 이미 많은 분들이 알고 있을테니 깊게 설명하지 않고 빠르게 넘어가겠다.

### Merge squash

![https://evan-moon.github.io/static/bc6a1dfaa1d43203ee77b5f4f1b442e1/c08c5/merge_squash_icon.jpg](https://evan-moon.github.io/static/bc6a1dfaa1d43203ee77b5f4f1b442e1/c08c5/merge_squash_icon.jpg)

이번에는 두 개의 브랜치를 병합할 때 사용하는 머지 명령어의 `--squash` 옵션을 한번 알아보자. `--squash` 옵션은 해당 브랜치의 커밋 전체를 통합한 커밋을 타겟 브랜치에 머지하는 옵션이다.

```jsx
$ git checkout master
$ git merge --squash feature
```

`일반 머지`는 머지가 되는 대상 브랜치의 모든 커밋이 남아있는 상태에서 타겟 브랜치로 합쳐지지만 `머지 스쿼시`는 대상 브랜치의 모든 커밋을 모아서 하나의 커밋으로 합치고 타겟 브랜치에 머지하는 방식이다. 사실 이 기능의 정확한 이름은 `Merge "and" Squash`이다. 즉, 스쿼시도 머지와 같이 독립된 하나의 개념이라는 것이다. `스쿼시`는 커밋을 여러 개 합친다는 개념이기 때문에 하단에 후술할 `rebase` 명령어와 함께 사용하여 현재 브랜치의 커밋을 합칠 때도 사용한다.

```jsx
$ git rebase -i HEAD~~
```

위 명령어는 `HEAD`부터 `HEAD`의 `~~(전전)` 커밋까지의 히스토리를 변경하겠다는 의미이다. 이 명령어를 입력하면 `vim`이 실행되고 아래와 같은 내용이 표시된다.

```jsx
pick 9a54fd4 commit의 설명 추가
pick 0d4a808 pull의 설명을 추가

# Rebase 326fc9f..0d4a808 onto d286baa
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#
```

위의 텍스트에 표시된 커밋들의 맨 앞에 있는 `pick` 문자를 `s`또는 `squash`로 변경하면 두 개의 커밋이 합쳐진다.

### Rebase

![https://evan-moon.github.io/static/40de34e1abf0e6be14897f662e2dfb2f/c08c5/rebase_icon.jpg](https://evan-moon.github.io/static/40de34e1abf0e6be14897f662e2dfb2f/c08c5/rebase_icon.jpg)

`리베이스(Rebase)`도 `머지(Merge)`와 마찬가지로 브랜치를 다른 브랜치로 합칠 수 있는 기능이다. 단 머지와 차이가 있다면 바로 `합치는 방식`이다. 머지는 말 그대로 두 개의 브랜치를 하나로 합치는 기능이기 때문에 `A` 브랜치의 변경 사항 전부를 `B` 브랜치에 푸쉬하는 것과 동일하다. 그렇기 때문에 머지를 사용하여 브랜치를 합치게 되면 반드시 `머지 커밋(Merge commit)`이 남게 된다.

```jsx
$ git checkout feature
$ git merge master
```

[출처] https://dzone.com/articles/merging-vs-rebasing

![https://evan-moon.github.io/ffb4536f7728ae28594958aaca9659e3/merge.svg](https://evan-moon.github.io/ffb4536f7728ae28594958aaca9659e3/merge.svg)

그렇기 때문에 머지는 어느 시점에 어떤 브랜치가 머지 되었는 지 커밋을 통해 알기 쉽다는 장점이 있다. 그러나 단점은 `불필요한 커밋`이 생성된다는 것이다. 이 단점은 작업 중인 브랜치가 별로 많지 않을 때는 나타나지 않지만 브랜치가 많아지면 나중엔 커밋 로그가 머지 커밋으로 뒤덮혀있는 광경을 볼 수도 있게 된다.

반면 리베이스는 단순히 합치는 것이 아니라 말 그대로 `브랜치의 베이스를 변경하는 것`이다. 방금 전 예시의 `feature` 브랜치를 `master`로 리베이스하게 되면 마치 `feature` 브랜치의 변경 사항들이 `master`의 변경 사항이었던 것처럼 히스토리가 기록된다.

```jsx
$ git checkout feature
$ git rebase master
```

[출처] https://dzone.com/articles/merging-vs-rebasing

![https://evan-moon.github.io/6480d07dcea3d4a3947bd5bb43c05f49/rebase.svg](https://evan-moon.github.io/6480d07dcea3d4a3947bd5bb43c05f49/rebase.svg)

리베이스의 장점은 바로 깔끔한 커밋 히스토리를 만들어 준다는 것이다. 머지 커밋이 남지 않고 애초에 `master`에서 수정한 것 마냥 히스토리가 남기 때문에 깔끔하게 일자로 쭉 떨어지는 이쁜 히스토리를 볼 수 있다. 하지만 리베이스의 단점은 바로 이 `커밋 끼워넣기`때문에 발생하는 문제이다.

[출처] https://dzone.com/articles/merging-vs-rebasing

![https://evan-moon.github.io/34e0fc3447edc79347d93a96fec5ecd9/rebase-problem.svg](https://evan-moon.github.io/34e0fc3447edc79347d93a96fec5ecd9/rebase-problem.svg)

필자가 만약 `feature` 브랜치를 `master`로 리베이스했다고 가정해보자. 이때 필자가 `feature` 브랜치를 생성한 이후에 `master`에 반영된 커밋들은 모두 맨 끝으로 이동하고 중간에 `feature` 브랜치의 커밋들을 끼워넣게 된다. 즉, 필자가 보고 있는 `master`의 상태는 `feature`의 변경 사항들이 반영되어 있는 히스토리를 가지고 있지만 다른 사람의 `master`는 아직 예전 `master`의 히스토리와 함께 일하고 있다는 것이다.

그럼 두개의 `master`를 강제로 병합해줘야하는데 병합 자체는 푸쉬할때 `--force` 옵션을 주면 되지만 문제는 이게 굉장히 혼란스러운 상황이라는 것이다. 쉽게 말해서 커밋 히스토리가 꼬이게 되고 사무실의 여기저기서 “어? 이거 왜 이래? 왜 푸시 안돼?”라는 소리가 들려오기 딱 좋은 상황이다.

그래서 `master`로의 병합은 머지 스쿼시를 사용하고 `develop`으로의 병합 때 리베이스를 사용하거나 하는 경우도 있다. 머지는 머지 커밋을 발생시키며 히스토리가 `미래`로 나아가기 때문에 이런 문제가 발생할 확률이 적지만, 리베이스는 `과거`를 변경하는 것이기 때문에 문제가 생기기 쉬운 것이다.

뭐 여러모로 둘 다 장단점이 있으니 잘 골라서 사용하도록 하자.

### Cherry Pick

`체리픽(Cherry Pick)`은 다른 브랜치에서 어떤 하나의 커밋만 내 브랜치로 가져오는 기능이다. 체리픽이 하는 일을 보면 대상 브랜치의 커밋 하나를 가져와서 현재 브랜치에 `병합`하는 행위라고 느껴지지만 히스토리를 보면 병합되는 그림이 아니라 그냥 해당 커밋을 그대로 복사해와서 내 브랜치에 커밋되는 형태로 기록된다.

```jsx
$ git checkout master
$ git cherry-pick 35058b4 # 가져올 커밋 해쉬
```

물론 체리픽을 사용할 때도 현재 브랜치의 소스와 충돌이 날 가능성은 있기 때문에 가져오기 전에 충돌을 수정할 수도 있다는 마음의 준비는 필요하다. 체리픽은 잘 쓰면 은근히 꿀 기능인데, 바로 이런 상황 때문이다.

> A 브랜치에서 철수가 기능 개발 중B 브랜치에서 영희가 기능 개발 중디자이너가 영희에게 리뷰 별점 아이콘과 디자인을 변경해달라고 요청영희가 B 브랜치에서 디자이너의 요구 사항을 반영근데 B 브랜치보다 A 브랜치가 먼저 배포되야 함디자이너가 철수에게 A 브랜치에 왜 리뷰 별점 디자인 반영안됐냐고 물어봄

제일 좋은 상황은 철수가 디자이너의 요구 사항을 반영하는 것이겠지만, 막 정신없이 일을 하다보면 그렇게 술술 풀리는 경우만 있는 게 아니기 때문에 이런 문제가 발생하긴 한다.

이때 철수는 영희가 작업하고 있는 B 브랜치에서 `리뷰 별점 아이콘이 수정된 커밋`을 A 브랜치로 체리픽함으로써 이 상황을 쉽게 해결할 수 있게 된다. 이런 사람 애매해지게 만드는 상황은 생각보다 자주 발생하기 때문에 체리픽에 익숙해지는 것을 추천한다.

사실 이 상황은 필자가 얼마 전에 겪은 상황인데 철수가 필자이고 영희가 동료 프론트엔드 개발자였다. 그래서 동료 개발자분과 B 브랜치의 커밋 로그를 봤는데, 리뷰 별점 아이콘만 수정된 커밋이 아니라 다른 변경 사항도 함께 묻어있는 커밋 밖에 없어서 디자이너와 딜을 할 수 밖에 없었고, “그럼 B 브랜치가 배포될 때 한꺼번에 같이 반영해주세요~“라는 결론으로 무사히 넘어갈 수 있었다. (디자이너님 감사감사…)

## 작업하던 사항을 임시로 저장해보자

### Stash

`스태쉬(Stash)`는 현재 작업 중인 변경 사항들을 잠시 스택에 저장할 수 있는 명령어이다. 이 명령어는 아직 마무리되지 않은 작업이 있는데 다른 브랜치로 체크아웃 해야하는 경우에 유용하게 사용할 수 있다.

```jsx
$ git stash # 현재 변경 사항들을 스택에 저장
$ git stash list # 스태쉬 목록을 확인
$ git stash apply # 가장 최근의 스태쉬를 다시 불러온다
```

또는 직접 스태쉬 이름을 지정할 수도 있다. 스태쉬의 이름을 지정하지 않으면 `스택에 들어간 순서(First In Last out)`대로만 스태쉬를 가져올 수 있으므로 왠만하면 이름을 지정하는 것을 추천한다. 필자는 주로 스태쉬 이름을 브랜치 이름과 동일하게 지정하는 편이다.

```jsx
$ git stash branch-name # 스태쉬 이름을 branch-name으로 지정하고 스택에 저장
$ git stash apply branch-name # branch-name 이름을 가진 스태쉬를 불러온다
```

실제로 회사에서 개발을 하다보면 갑자기 긴급한 버그 픽스 건이 들어온다거나 아니면 PO들이 이슈의 우선 순위를 다시 정리하면서 기존에 작업을 하고 있던 브랜치에서 다른 브랜치로 건너가야하는 경우는 꽤나 빈번하게 발생한다. (특히 버그 픽스…) 이때 다른 브랜치로 넘어가기위해 작업하던 것을 그대로 커밋하게 되면 해당 브랜치에서 함께 개발하고 있는 다른 팀원들에게 피해가 갈 수 있으니 반드시 변경 사항을 `스태쉬`하도록 하자.

## 이미 커밋한 내용 되돌리기

개발을 진행하다보면 가끔 커밋을 다시 되돌려야 하는 경우도 생긴다. 보통 실수로 인해서 이런 상황이 발생하는 것을 많이 봤는데, 배포되지 말아야 할 기능이 `release` 브랜치에 껴서 들어간 경우를 제일 많이 본 것같다. 이런 상황에서 그 기능의 코드를 일일히 찾아 손으로 지우는 것은 너무 위험하기 때문에 Git을 사용하여 커밋을 되돌리게 된다. 이때 사용하는 기능이 바로 `Reset`과 `Revert`이다.

### Reset

`리셋(Reset)`은 지정한 커밋 당시로 돌아가는 것이다. 아예 시간을 되돌린다고 생각하면 된다. 즉, 리셋을 사용하게되면 지정한 커밋 이후의 히스토리는 모두 사라지게 된다. 예를 들어 이런 히스토리가 있다고 생각해보자.

```jsx
19061e7 - 맛없는 식당을 찾은 죄로 여자친구한테 이별 통보를 받았다.
|
* e50aff9 - 여자친구가 맛이 없다고 한다.
|
* 2d57c29 - 알리오 올리오를 주문했다.
|
* c04f8f6 - 찾아본 식당에 방문했다.
|
* 7d9d953 - 여자친구와 함께 갈 좋은 식당을 찾았다!
```

필자는 여친과 함께 방문할 좋은 식당을 찾아서 기대감을 안고 알리오 올리오를 주문했지만 너무 느끼하고 맛이 없어서 결과적으로 여친한테 차이고 말았다.

그래서 필자는 너무 슬픈 나머지 기억을 지우고 싶어서 알리오 올리오를 주문하기 전으로 돌아가려고 한다. 이때 사용할 수 있는 명령어가 `reset`이다. 돌아가고 싶은 커밋을 지정하면 해당 커밋 이후의 히스토리는 모두 삭제하고 과거로 돌아갈 수 있다.

```jsx
$ git reset --hard c04f8f6

# 식당을 방문했을 때로 돌아갔다!
* c04f8f6 - 찾아본 식당에 방문했다.
|
* 7d9d953 - 여자친구와 함께 갈 좋은 식당을 찾았다!
```

우리는 `reset` 명령어를 사용할 때 3개의 옵션을 사용할 수 있는데, 바로 `hard`, `soft`, `mixed`이다. 이 옵션들은 히스토리를 삭제한다는 것은 전부 동일하지만 삭제된 내용을 처리하는 방식이 조금씩 다르다.

> hard: 지정한 커밋 이후의 히스토리가 삭제되고 삭제된 내용들은 그대로 사라진다.soft: 지정한 커밋 이후의 히스토리가 삭제되고 삭제된 내용들은 스테이지로 이동한다.(add한 상태로 변경)mixed: 지정한 커밋 이후의 히스토리가 삭제되고 삭제된 내용들은 스테이지에 올라가지 않은 상태가 된다.(다시 add 해줘야 함)

필자는 방금 위에서 `hard` 옵션을 사용했기 때문에 식당을 방문했던 커밋 이후의 잊고 싶었던 기억을 모두 깔끔하게 삭제할 수 있었다. 만약 옵션을 지정하지 않고 `reset` 명령어를 사용하면 `mixed` 옵션으로 작동한다. 그리고 만약 이미 되돌리고자 하는 히스토리가 리모트 저장소에 푸쉬까지 된 상태라면 리셋 후 히스토리를 푸쉬할 때 `--force` 옵션을 사용해야한다.

### Revert

`리벗(revert)` 또한 리셋처럼 히스토리를 다시 되돌리고 싶을 때 사용하는 명령어이다. `리셋`이 지정한 커밋 이후의 모든 히스토리를 없애버렸다면 `리벗`은 특정 커밋의 변경 사항을 되돌리는 기능이다. 이때 해당 커밋을 되돌린다고 해서 히스토리에서 그 커밋을 삭제하는 것이 아니라, 되돌리고자 하는 커밋의 내용을 반전시키는 것이다.

```jsx
$ git revert 35058b4 # 특정 커밋을 되돌린다
$ git revert 35058b4..c04f8f6 # 커밋의 범위를 지정하여 되돌린다
$ git revert HEAD # 현재 헤드가 위치한 커밋을 되돌린다
```

만약 `35058b4` 커밋에서 `A.js`의 `2`번 라인에 `a`라는 글자가 추가되었다고 하면 `git revert 35058b4`를 사용했을때 `A.js`의 `2`번 라인에서 `a`를 다시 삭제하는 것이다. 즉, 추가된 사항은 제거하고 제거된 사항은 다시 추가한다. 말 그대로 지정한 커밋의 변경 사항을 반전하고 다시 커밋하는 것이다. 그렇기 때문에 리벗은 리셋과 다르게 히스토리를 삭제하지 않고 하나의 커밋이 추가되는 형태로 히스토리가 남는다.

```jsx
35058b4 - Revert 맛없는 식당을 찾은 죄로 여자친구한테 이별 통보를 받았다. # 여친한테 차인 히스토리만 리벗하자
|
* 19061e7 - 맛없는 식당을 찾은 죄로 여자친구한테 이별 통보를 받았다.
|
* e50aff9 - 여자친구가 맛이 없다고 한다.
|
* 2d57c29 - 알리오 올리오를 주문했다.
|
* c04f8f6 - 찾아본 식당에 방문했다.
|
* 7d9d953 - 여자친구와 함께 갈 좋은 식당을 찾았다!
```

위의 예시에서 필자는 여친한테 차인 커밋을 다시 리벗했지만 히스토리 상에는 필자의 흑역사가 고스란히 남아있다.(다시 말하지만 실제 상황 아닙니다) 보통 필자는 리벗을 자주 사용하지는 않지만 가끔 테스트용으로 넣었던 `console.log`가 껴서 들어가거나 할 때 해당 커밋을 리벗 해본 적은 있다. `리셋`과 `리벗` 둘 다 변경 사항을 되돌리는 기능이지만, 되돌리는 방법은 완전 다르니 적재적소에 잘 사용해보도록 하자.

[출처] [https://evan-moon.github.io/](https://evan-moon.github.io/)
